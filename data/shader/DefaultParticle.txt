#include "ConstantHeader.txt"
Texture2D	g_ColorTex		: register(t9);

struct VS_in
{
	float3 p : POSITION;
	float3 n : NORMAL;
	float4 c : COLOR;
	float2 t : TEXCOORD;
	uint iVID : SV_InstanceID;
};
struct VS_out
{
	float4 p : SV_POSITION;
	float3 n : NORMAL;
	float4 c : COLOR0;
	float2 t : TEXCOORD0;
	float3 w : TEXCOORD1;
};

cbuffer InstancingData : register(b8)
{
	matrix g_mInstancing[500];
	float4 g_vInstColor[500];
};

VS_out VS(VS_in input)
{
	VS_out output = (VS_out)0;

	float4 pos = 0;
	float4 normal = 0;

	float4 vLocal = float4(input.p, 1.0f);
	float4 vWorld = mul(vLocal, g_mInstancing[input.iVID]);
	float4 vView = mul(vWorld, g_matView);
	float4 vProj = mul(vView, g_matProj);

	output.p = vProj;
	output.n = normal;
	output.c = input.c * g_vInstColor[input.iVID];
	output.t = input.t;

	return output;
}

struct PS_OUT
{
	float4 vColor :SV_TARGET0;//add(+)
	float4 vBlack :SV_TARGET1;//multiply(*)
};

PS_OUT PS(VS_out input) : SV_Target
{
	PS_OUT vOut;
	vOut.vColor = g_txTexA.Sample(g_SampleWrap, input.t);
	vOut.vColor.rgb = vOut.vColor.rgb * input.c.rgb * input.c.a;
	vOut.vColor.a = 1;

	vOut.vBlack = float4(1 - vOut.vColor.r, 1 - vOut.vColor.g, 1 - vOut.vColor.b, 1);
	return vOut;
}

float4 Distortion(VS_out input) : SV_Target
{
	float4 vOut;
	float4 color = g_txTexA.Sample(g_SampleWrap, input.t);
	float2 fWeight = color.rg * 0.5f - 0.5;
	fWeight = fWeight * 0.2;

	float2 xy; ((input.p.xy / 2048.0f) + 1) / 2;
	xy.x = input.p.x / 2048.0f;
	xy.y = input.p.y / 2048.0f;

	vOut = g_ColorTex.Sample(g_SampleWrap, xy + fWeight);
	float alpha =  (0.5 - (abs(input.t.x - 0.5))) + (0.5 - (abs(input.t.y - 0.5)));
	vOut.a = alpha;
	if(color.a <= 0.1)
		vOut.a = 0;

	return vOut;
}

float4 COLOR_PS(VS_out input) : SV_Target
{
	return input.c;
}